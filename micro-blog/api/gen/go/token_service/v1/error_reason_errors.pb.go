// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package v1

import (
	fmt "fmt"
	errors "github.com/devexps/go-micro/v2/errors"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the micro package it is being compiled against.
const _ = errors.SupportPackageIsVersion1

// create token failed
func IsCreateTokenFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_CREATE_TOKEN_FAILED.String() && e.Code == 101
}

// create token failed
func ErrorCreateTokenFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(101, ErrorReason_CREATE_TOKEN_FAILED.String(), fmt.Sprintf(format, args...))
}

// save token failed
func IsSaveTokenFailed(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_SAVE_TOKEN_FAILED.String() && e.Code == 102
}

// save token failed
func ErrorSaveTokenFailed(format string, args ...interface{}) *errors.Error {
	return errors.New(102, ErrorReason_SAVE_TOKEN_FAILED.String(), fmt.Sprintf(format, args...))
}

// token expired
func IsTokenExpired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_TOKEN_EXPIRED.String() && e.Code == 103
}

// token expired
func ErrorTokenExpired(format string, args ...interface{}) *errors.Error {
	return errors.New(103, ErrorReason_TOKEN_EXPIRED.String(), fmt.Sprintf(format, args...))
}

// token invalid
func IsInvalidToken(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_INVALID_TOKEN.String() && e.Code == 104
}

// token invalid
func ErrorInvalidToken(format string, args ...interface{}) *errors.Error {
	return errors.New(104, ErrorReason_INVALID_TOKEN.String(), fmt.Sprintf(format, args...))
}

// token not exist
func IsTokenNotExist(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_TOKEN_NOT_EXIST.String() && e.Code == 105
}

// token not exist
func ErrorTokenNotExist(format string, args ...interface{}) *errors.Error {
	return errors.New(105, ErrorReason_TOKEN_NOT_EXIST.String(), fmt.Sprintf(format, args...))
}

// no jwt token in context
func IsNoTokenInContext(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_NO_TOKEN_IN_CONTEXT.String() && e.Code == 106
}

// no jwt token in context
func ErrorNoTokenInContext(format string, args ...interface{}) *errors.Error {
	return errors.New(106, ErrorReason_NO_TOKEN_IN_CONTEXT.String(), fmt.Sprintf(format, args...))
}

// claims is nil
func IsClaimsIsNil(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_CLAIMS_IS_NIL.String() && e.Code == 107
}

// claims is nil
func ErrorClaimsIsNil(format string, args ...interface{}) *errors.Error {
	return errors.New(107, ErrorReason_CLAIMS_IS_NIL.String(), fmt.Sprintf(format, args...))
}

// claims is not map claims
func IsClaimsIsNotMap(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ErrorReason_CLAIMS_IS_NOT_MAP.String() && e.Code == 108
}

// claims is not map claims
func ErrorClaimsIsNotMap(format string, args ...interface{}) *errors.Error {
	return errors.New(108, ErrorReason_CLAIMS_IS_NOT_MAP.String(), fmt.Sprintf(format, args...))
}
